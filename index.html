<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OrbitingIdeas SimLab</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.3/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.3/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.3/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <!-- Replace Cannon.js with Ammo.js -->
    <script src=./builds/ammo.js></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link rel="stylesheet" href="./style.css">
<style>
    body {
        font-family: 'Space Mono', monospace;
        background-color: #0A0F1A;
        color: #E0E0E0;
    }
    .glassmorphism {
        background: rgba(12, 20, 39, 0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 190, 255, 0.2);
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    }
    .custom-scrollbar::-webkit-scrollbar {
        width: 8px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
        background: #0A0F1A;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #007BFF;
        border-radius: 4px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: #0056b3;
    }
    .btn-primary {
        background-color: #007BFF;
        color: white;
        transition: all 0.3s ease;
        border: 1px solid #0056b3;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px;
        border-radius: 6px;
        font-weight: bold;
    }
    .btn-primary:hover {
        background-color: #0056b3;
        box-shadow: 0 0 10px #007BFF;
    }
    .btn-secondary {
        background-color: #1A2C47;
        color: #00BEFF;
    }
    .btn-secondary:hover {
        background-color: #2a4163;
    }
    .btn-active {
        background-color: #00BEFF !important;
        color: #0A0F1A !important;
        box-shadow: 0 0 15px #00BEFF;
    }
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 8px;
        background: #1A2C47;
        outline: none;
        opacity: 0.9;
        transition: opacity .2s;
        border-radius: 4px;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #00BEFF;
        cursor: pointer;
        border-radius: 50%;
        border: 2px solid #0A0F1A;
    }
    .sim-item {
        transition: all 0.2s ease-in-out;
        border-left: 4px solid transparent;
    }
    .sim-item:hover {
        background-color: #1A2C47;
        border-left-color: #00BEFF;
    }
    .sim-item.active {
        background-color: #00BEFF;
        color: #0A0F1A;
        font-weight: bold;
        border-left-color: #80DFFF;
    }
    .telemetry-value {
        color: #00BEFF;
        font-weight: bold;
    }
    .vector-input input, .scalar-input {
        background-color: #1A2C47;
        border: 1px solid #007BFF;
        border-radius: 4px;
        text-align: center;
        width: 100%;
        padding: 4px;
    }
    .input-error {
        border-color: #FF3131 !important;
        box-shadow: 0 0 8px #FF3131;
    }
    main {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        height: calc(100vh - 64px); /* Explicitly set main height */
    }
    #simulation-container {
        flex-grow: 1;
        position: relative;
        width: 100%;
        height: 100%;
    }
    #simulation-canvas {
        width: 100% !important;
        height: 100% !important;
        display: block;
        position: absolute;
        top: 0;
        left: 0;
    }
    #telemetry-column {
        flex-grow: 1;
        overflow-y: auto;
        width: 100%;
    }
    #sidebar {
        transition: transform 0.3s ease;
        transform: translateX(0);
    }
    #sidebar.collapsed {
        transform: translateX(-100%);
    }
    #sidebar.collapsed + #simulation-container {
        width: 100% !important; /* Expand simulation container */
    }
    #simulation-list-container {
        max-height: 40vh;
        transition: max-height 0.3s ease;
    }
    #simulation-list-container.constrained {
        max-height: calc(3 * 3.5rem);
    }
    [data-tooltip]:hover:after {
        content: attr(data-tooltip);
        position: absolute;
        background: #1A2C47;
        color: #E0E0E0;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 10;
    }
    @media (max-width: 1023px) {
        #sidebar {
            position: absolute;
            z-index: 10;
            height: calc(100vh - 64px);
            width: 100%;
        }
        #sidebar.collapsed {
            transform: translateX(-100%);
        }
        #simulation-container {
            width: 100%;
            height: calc(100vh - 64px); /* Full height minus header */
            min-height: 50vh;
        }
        #telemetry-column {
            width: 100%;
            height: calc(100vh - 64px); /* Full height minus header */
            min-height: 0;
        }
        #sidebar.collapsed ~ #simulation-container,
        #sidebar.collapsed ~ #telemetry-column {
            height: calc(100vh - 64px) !important; /* Maintain height */
        }
        #telemetry-panel {
            grid-template-columns: 1fr;
        }
        #parameter-modal {
            padding: 1rem;
        }
        #parameter-modal > div {
            max-width: 100%;
            min-width: 0;
        }
        #simulation-list-container.constrained {
            max-height: calc(3 * 3rem);
        }
    }
    @media (min-width: 1024px) {
        #sidebar {
            position: relative;
        }
        main {
            flex-direction: row;
            height: 100vh; /* Full viewport height */
        }
        #simulation-container {
            width: calc(100% - 4/12 * 100%); /* Adjusted for wider sidebar */
            height: 100%;
            min-height: 0;
        }
        #telemetry-column {
            width: calc(3/12 * 100%);
            height: 100%;
        }
    }
    #telemetry-chart {
        max-height: 200px;
        width: 100% !important;
        height: 200px !important;
    }
</style>
</head>
<body class="flex flex-col h-screen overflow-hidden">
    <header class="bg-black/30 glassmorphism text-white p-2 sm:p-3 shadow-lg border-b border-blue-500/30 flex items-center justify-between z-20 flex-shrink-0">
        <div class="flex items-center space-x-2 sm:space-x-4">
            <button id="toggle-sidebar-btn" class="btn-primary p-2" title="Toggle Sidebar">
                <i data-lucide="chevron-left" class="h-4 w-4"></i>
            </button>
            <button id="back-btn" class="btn-primary hidden"><i data-lucide="arrow-left" class="h-4 w-4"></i></button>
            <a href="https://www.orbitingideas.com">
                <img src="./assets/logo.png" alt="Logo" class="text-blue-400 h-[31px] w-[100px]">
            </a>
            <h1 class="text-base sm:text-lg md:text-2xl tracking-wider font-['Montserrat'] font-bold">SimLab</h1>
        </div>
        <div class="flex items-center text-xs sm:text-sm">
            <span class="hidden sm:inline mr-2">SIM ENGINE:</span>
            <span id="engine-status-indicator" class="w-3 h-3 rounded-full bg-yellow-400 inline-block mr-2"></span>
            <span id="engine-status-text" class="text-yellow-400">STANDBY</span>
            <button id="audio-btn" class="btn-primary ml-4" title="Toggle Audio">
                <i data-lucide="volume-2" class="h-4 w-4"></i>
            </button>
        </div>
    </header>
    <audio id="background-audio" autoplay loop muted>
        <source src="./space_music.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
<main class="flex-grow flex flex-col lg:flex-row overflow-hidden">
    <aside id="sidebar" class="w-full lg:w-4/12 glassmorphism p-4 flex flex-col overflow-y-auto custom-scrollbar border-b lg:border-b-0 lg:border-r border-blue-500/30 transition-transform duration-300">
        <h2 class="text-base sm:text-lg font-semibold text-blue-300 border-b border-blue-400/50 pb-2 mb-3 flex items-center">
            <i data-lucide="rocket" class="h-4 w-4 mr-2"></i>Simulations
        </h2>
        <div id="simulation-list-container" class="space-y-2 mb-6 flex-shrink-0 overflow-y-auto custom-scrollbar pr-2"></div>
        <div id="active-sim-controls" class="hidden flex-grow flex flex-col">
            <h2 class="text-base sm:text-lg font-semibold text-blue-300 mb-3 border-b border-blue-400/50 pb-2 flex items-center">
                <i data-lucide="gamepad-2" class="h-4 w-4 mr-2"></i>Controls
            </h2>
            <div class="flex space-x-2 mb-4">
                <button id="start-btn" class="btn-primary flex-1"><i data-lucide="play" class="h-4 w-4 mr-2"></i>Start</button>
                <button id="stop-btn" class="btn-primary flex-1"><i data-lucide="pause" class="h-4 w-4 mr-2"></i>Stop</button>
                <button id="reset-btn" class="btn-primary flex-1"><i data-lucide="rotate-cw" class="h-4 w-4 mr-2"></i>Reset</button>
            </div>
            <button id="open-params-btn" class="btn-primary btn-secondary w-full mb-6">
                <i data-lucide="sliders-horizontal" class="h-4 w-4 mr-2"></i>All Parameters
            </button>
            <div id="quick-access-parameters-panel" class="space-y-4 mb-6 overflow-y-auto custom-scrollbar"></div>
            <div id="user-controls-panel" class="mb-6 hidden">
                <h2 class="text-base sm:text-lg font-semibold text-blue-300 mb-3 border-b border-blue-400/50 pb-2 flex items-center">
                    <i data-lucide="mouse-pointer-click" class="h-4 w-4 mr-2"></i>Vehicle Control
                </h2>
                <div id="user-controls-content" class="text-center bg-black/30 p-3 rounded-lg mt-2 border border-blue-500/20"></div>
            </div>
            <div class="mt-auto text-xs text-gray-500 text-center pt-4">
                <p>Orbit: LMB+drag, Zoom: Scroll, Pan: RMB+drag</p>
                <p>© 2025 AeroLab Project</p>
            </div>
        </div>
        <div id="standby-panel" class="flex-grow flex items-center justify-center text-gray-600">
            <div class="text-center">
                <p>Select a simulation</p>
                <p>to begin.</p>
            </div>
        </div>
    </aside>
    <section id="simulation-container" class="flex-grow w-full lg:w-5/12 bg-black relative">
        <canvas id="simulation-canvas" class="w-full h-full"></canvas>
        <div id="viewport-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-600">
            <div class="text-center">
                <i data-lucide="scan-eye" class="h-16 w-16 sm:h-24 sm:w-24 mx-auto mb-4"></i>
                <p class="text-lg sm:text-xl">VIEWER OFFLINE</p>
                <p>Select a simulator from the list to begin.</p>
            </div>
        </div>
    </section>
    <aside id="telemetry-column" class="w-full lg:w-3/12 glassmorphism p-4 flex flex-col overflow-y-auto custom-scrollbar border-t lg:border-t-0 lg:border-l border-blue-500/30">
        <div id="telemetry-placeholder" class="flex-grow flex items-center justify-center text-gray-600">
            <div class="text-center">
                <i data-lucide="activity" class="h-16 w-16 sm:h-24 sm:w-24 mx-auto mb-4"></i>
                <p>Awaiting telemetry stream...</p>
            </div>
        </div>
        <div id="active-sim-telemetry" class="hidden flex-1">
            <h2 class="text-base sm:text-lg font-semibold text-blue-300 mb-3 border-b border-blue-400/50 pb-2 flex items-center">
                <i data-lucide="activity" class="h-4 w-4 mr-2"></i>Live Telemetry
            </h2>
            <div id="telemetry-panel" class="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-6 font-mono text-sm"></div>
            <h2 class="text-base sm:text-lg font-semibold text-blue-300 mb-3 border-b border-blue-400/50 pb-2 flex items-center">
                <i data-lucide="line-chart" class="h-4 w-4 mr-2"></i>Data Plot
            </h2>
            <div class="mb-3">
                <label for="telemetry-select" class="block text-sm font-medium text-gray-300 mb-1">Select Metric to Plot</label>
                <select id="telemetry-select" class="bg-[#1A2C47] border border-blue-500/50 rounded-md p-2 text-sm text-blue-300 w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <div class="bg-black/30 p-2 rounded-md mt-2 border border-blue-500/20 flex-grow" style="height:220px; min-height:200px;">
                <canvas id="telemetry-chart" style="width:100% !important; height:200px !important;"></canvas>
            </div>
        </div>
    </aside>
</main>

    <div id="parameter-modal" class="fixed inset-0 z-50 hidden bg-black/70 flex items-center justify-center p-2 sm:p-4">
        <div class="glassmorphism p-4 sm:p-6 rounded-xl shadow-2xl w-full max-w-md border-blue-400">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg sm:text-xl font-bold text-blue-200 flex items-center">
                    <i data-lucide="settings-2" class="h-5 w-5 mr-3"></i>Parameters
                </h2>
                <button id="close-params-btn" class="text-gray-400 hover:text-red-400 text-xl sm:text-2xl">×</button>
            </div>
            <div id="parameter-form" class="space-y-4 max-h-[60vh] overflow-y-auto custom-scrollbar pr-2"></div>
            <div id="validation-error-msg" class="text-red-400 text-sm mt-4 hidden">Please fix the invalid fields before applying.</div>
            <div class="flex gap-4 mt-6">
                <button id="apply-live-btn" class="btn-primary btn-secondary flex-1" type="button">
                    <i data-lucide="zap" class="h-4 w-4 mr-2"></i>Apply
                </button>
                <button id="save-and-reset-btn" class="btn-primary flex-1" type="button">
                    <i data-lucide="save" class="h-4 w-4 mr-2"></i>Apply & Reset
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Wait for Ammo.js to load
        Ammo().then(function(Ammo) {

        // Global state
        let scene, camera, renderer, world, clock, starfield, chart;
        let activeSimulation = null;
        let simulationRunning = false;
        let animationFrameId;
        let objectsToUpdate = [];
        let currentParameters = {};
        let modalParameters = {};
        let eventListeners = [];
        let isMouseDown = false, isRightMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let orbitControls = null;
        let cameraControlType = 'none';
        const simContainer = document.getElementById('simulation-container');
        const canvas = document.getElementById('simulation-canvas');
        const parameterModal = document.getElementById('parameter-modal');
        const simulationConfig = {
            maxObjects: 1000,
            defaultCamera: { fov: 75, near: 0.1, far: 100000, position: new THREE.Vector3(0, 50, 200) },
            chartColors: ['#00BEFF', '#FF6B6B', '#FFD166', '#4DDB6A'],
            defaultUpdateInterval: 1 / 60, // Default physics timestep (seconds)
            defaultTimeScale: 1.0,
        };

        function enableCameraControl(type) {
            removeCustomCameraListeners();
            if (orbitControls) {
                orbitControls.dispose();
                orbitControls = null;
            }

            cameraControlType = type;
            if (type === 'custom') {
                addCustomCameraListeners();
            } else if (type === 'orbit') {
                orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
                // Optionally set limits, speeds, etc.
                orbitControls.target.copy(objectsToUpdate[0]?.cameraTarget || new THREE.Vector3(0,0,0));
                orbitControls.update();
            }
        }
        
        // Input Manager for handling keyboard and button inputs
        class InputManager {
            constructor() {
                this.listeners = [];
                this.keyStates = {};
                this.buttonMap = {
                    'up-thrust': 'ArrowUp',
                    'down-thrust': 'ArrowDown',
                    'left-thrust': 'ArrowLeft',
                    'right-thrust': 'ArrowRight'
                };
                this.setupGlobalListeners();
            }

            setupGlobalListeners() {
                this.listeners.push(
                    { element: window, event: 'keydown', listener: (e) => this.keyStates[e.key] = true },
                    { element: window, event: 'keyup', listener: (e) => this.keyStates[e.key] = false }
                );
                this.listeners.forEach(({ element, event, listener }) => element.addEventListener(event, listener));
            }

            setupButtonListeners(simulationId) {
                if (simulationId !== 'lunarLander') return;
                document.querySelectorAll('#user-controls-content button').forEach(button => {
                    if (this.buttonMap[button.id]) {
                        this.listeners.push(
                            { element: button, event: 'mousedown', listener: () => this.keyStates[this.buttonMap[button.id]] = true },
                            { element: button, event: 'mouseup', listener: () => this.keyStates[this.buttonMap[button.id]] = false },
                            { element: button, event: 'mouseleave', listener: () => this.keyStates[this.buttonMap[button.id]] = false }
                        );
                    }
                });
                this.listeners.slice(-3 * document.querySelectorAll('#user-controls-content button').length).forEach(({ element, event, listener }) => element.addEventListener(event, listener));
            }

            update(simulationId) {
                if (simulationId !== 'lunarLander' || !activeSimulation?.userControls?.keys) return;
                Object.entries(this.keyStates).forEach(([key, value]) => {
                    activeSimulation.userControls.keys[key] = value;
                    const btnId = Object.keys(this.buttonMap).find(id => this.buttonMap[id] === key);
                    if (btnId) document.getElementById(btnId)?.classList.toggle('btn-active', value);
                });
            }

            cleanup() {
                this.listeners = this.listeners.filter(l => l.element === window); // Keep global listeners
                this.keyStates = {};
            }
        }

        const inputManager = new InputManager();

        // Utility functions
        const utils = {
            createMesh: (geometry, materialProps) => {
                const material = new THREE.MeshStandardMaterial(materialProps);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.geometry.computeBoundingSphere();
                return mesh;
            },
            createParticleSystem: (count, size, color) => {
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * size;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * size;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * size;
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                const material = new THREE.PointsMaterial({
                    size: size / 10,
                    vertexColors: true,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                return new THREE.Points(particles, material);
            },
            disposeObject: (obj) => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => {
                            if (mat.map) mat.map.dispose();
                            mat.dispose();
                        });
                    } else {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                }
                if (obj.isInstancedMesh) obj.dispose();
                if (obj.children) obj.children.forEach(child => utils.disposeObject(child));
            },
            applyForce: (body, force) => {
                const forceVec = new Ammo.btVector3(force.x(), force.y(), force.z());
                body.applyForce(forceVec, new Ammo.btVector3(0, 0, 0)); // Apply at center of mass
                Ammo.destroy(forceVec);
            },
            applyTorque: (body, torque) => {
                const torqueVec = new Ammo.btVector3(torque.x(), torque.y(), torque.z());
                body.applyTorque(torqueVec);
                Ammo.destroy(torqueVec);
            },
            validateNumber: (value, min, max) => {
                const num = parseFloat(value);
                if (isNaN(num)) return false;
                if (min !== undefined && num < min) return min;
                if (max !== undefined && num > max) return max;
                return num;
            },
            debounce: (func, wait) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func(...args), wait);
                };
            }
        };

        // Simulation class
        class Simulation {
            constructor(id, config) {
                this.id = id;
                this.name = config.name;
                this.parameters = config.parameters;
                this.telemetry = config.telemetry;
                this.userControls = config.userControls;
                this.cameraControl = config.cameraControl;
                this.cameraSettings = config.cameraSettings || simulationConfig.defaultCamera;
                this.updateInterval = config.updateInterval || simulationConfig.defaultUpdateInterval; // New
                this.init = config.init.bind(this);
                this.update = config.update?.bind(this) || (() => {});
                this.updateParameters = config.updateParameters?.bind(this) || (() => {});
                this.getTelemetry = config.getTelemetry.bind(this);
                this.state = {};
            }
        }

       const simulations = {
            leoSatelliteSim: new Simulation('leoSatelliteSim', {
            name: 'LEO Satellite Simulator',
            cameraControl: 'orbit',
            parameters: [
                { id: 'kp', label: 'Proportional Gain (Kp)', type: 'scalar', control: 'slider', min: 0, max: 10, step: 0.01, defaultValue: 0.04 },
                { id: 'ki', label: 'Integral Gain (Ki)', type: 'scalar', control: 'slider', min: 0, max: 5, step: 0.01, defaultValue: 0.0 },
                { id: 'kd', label: 'Derivative Gain (Kd)', type: 'scalar', control: 'slider', min: 0, max: 10, step: 0.01, defaultValue: 10.0 },
                { id: 'q_desired', label: 'Desired Quaternion', type: 'vector4d', defaultValue: { w: 1.0, x: 0.0, y: 0.0, z: 0.0 } },
                { id: 'mu', label: 'Gravitational Parameter', units: 'm³/s²', type: 'scalar', defaultValue: 3.986e14 },
                { id: 'r_earth', label: 'Earth Radius', units: 'm', type: 'scalar', defaultValue: 6371e3 },
                { id: 'rho_0', label: 'Reference Density', units: 'kg/m³', type: 'scalar', min: 0, max: 1e-9, step: 0.01e-9, defaultValue: 0 },
                { id: 'h_scale', label: 'Scale Height', units: 'm', type: 'scalar', defaultValue: 100e3 },
                { id: 'solar_pressure', label: 'Solar Pressure', units: 'N/m²', type: 'scalar', min: 0, max: 6e-6, step: 0.01e-6, defaultValue: 0 },
                { id: 'c_light', label: 'Speed of Light', units: 'm/s', type: 'scalar', defaultValue: 3e8 },
                { id: 'max_torque', label: 'Max Control Torque', units: 'N·m', type: 'scalar', control: 'slider', min: 0.0001, max: 0.1, step: 0.01, defaultValue: 0.1 },
                { id: 'timeScale', label: 'Simulation Speed', type: 'scalar', control: 'slider', min: 0.1, max: 100, step: 0.1, defaultValue: 1.0 }
            ],
            telemetry: [
                { id: 'Time', type: 'scalar' },
                { id: 'Simulation Speed', type: 'scalar' },
                { id: 'Radius', type: 'scalar' },
                { id: 'Latitude', type: 'scalar' },
                { id: 'Longitude', type: 'scalar' },
                { id: 'Radial Velocity', type: 'scalar' },
                { id: 'Tangential Velocity', type: 'scalar' },
                { id: 'Azimuth', type: 'scalar' },
                { id: 'Quaternion', type: 'vector4d', ids: ['w', 'x', 'y', 'z'] },
                { id: 'Position', type: 'vector3d', ids: ['x', 'y', 'z'] }
            ],
            userControls: null,
            cameraSettings: { position: new THREE.Vector3(0, 0, (6371e3 + 400e3) * 1.5), near: 1e5, far: 1e9 },
            init: async function(params) {
                world.setGravity(new Ammo.btVector3(0, 0, 0));
                this.state = {
                    I: new Ammo.btVector3(10.0, 8.0, 5.0), // Diagonal inertia (Ixx, Iyy, Izz)
                    integralError: new Ammo.btVector3(0, 0, 0),
                    currentTime: 0.0,
                    timeScale: params.timeScale || simulationConfig.defaultTimeScale,
                    loader: new THREE.GLTFLoader(),
                    earthModel: null,
                    satModel: null,
                    mass: 500 // Store mass here
                };

                // Load space skybox
                scene.background = new THREE.CubeTextureLoader().load([
                    './skybox/space/bkg1_right1.png',
                    './skybox/space/bkg1_left2.png',
                    './skybox/space/bkg1_top3.png',
                    './skybox/space/bkg1_bottom4.png',
                    './skybox/space/bkg1_front5.png',
                    './skybox/space/bkg1_back6.png'
                ]);

                // Configure camera
                camera = new THREE.PerspectiveCamera(
                    70,
                    canvas.clientWidth / canvas.clientHeight,
                    1e5,
                    1e9
                );
                camera.position.copy(this.cameraSettings.position);
                camera.lookAt(0, 0, 0);
                camera.updateProjectionMatrix();

                // Load Earth model
                try {
                    const earthGltf = await new Promise((resolve, reject) => {
                        this.state.loader.load(
                            './models/Earth_1_12756.glb',
                            resolve,
                            undefined,
                            (error) => reject(new Error(`Failed to load Earth model: ${error.message}`))
                        );
                    });
                    this.state.earthModel = earthGltf.scene;
                    this.state.earthModel.scale.setScalar(12742);
                    this.state.earthModel.name = 'earth';
                    scene.add(this.state.earthModel);
                } catch (error) {
                    console.error(error.message);
                }

                // Create satellite body
                const sphereShape = new Ammo.btSphereShape(1);
                const mass = this.state.mass; // Use stored mass
                const inertia = new Ammo.btVector3(10, 8, 5);
                const startTransform = new Ammo.btTransform();
                startTransform.setIdentity();
                startTransform.setOrigin(new Ammo.btVector3(0, 0, params.r_earth + 400e3));
                const motionState = new Ammo.btDefaultMotionState(startTransform);
                const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, sphereShape, inertia);
                const satBody = new Ammo.btRigidBody(rbInfo);
                satBody.setLinearVelocity(new Ammo.btVector3(7676, 0, 0));
                satBody.setAngularVelocity(new Ammo.btVector3(0, 0, 0));
                world.addRigidBody(satBody);
                Ammo.destroy(inertia);
                Ammo.destroy(startTransform);
                Ammo.destroy(rbInfo);

                try {
                    const satGltf = await new Promise((resolve, reject) => {
                        this.state.loader.load(
                            './models/AcrimSAT.glb',
                            resolve,
                            undefined,
                            (error) => reject(new Error(`Failed to load satellite model: ${error.message}`))
                        );
                    });
                    this.state.satModel = satGltf.scene;
                    this.state.satModel.scale.setScalar(120000);
                    this.state.satModel.name = 'satellite';
                    scene.add(this.state.satModel);
                } catch (error) {
                    console.error(error.message);
                    this.state.satModel = utils.createMesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        { color: 0xffffff, metalness: 0.9, roughness: 0.2 }
                    );
                    this.state.satModel.scale.setScalar(30000);
                    scene.add(this.state.satModel);
                }

                // Add axes helper
                const axesHelper = new THREE.AxesHelper(2e7);
                scene.add(axesHelper);

                this.updateParameters(params);
                return [{ mesh: this.state.satModel, body: satBody, cameraTarget: new THREE.Vector3(0, 0, 0) }];
            },
            updateParameters: function(params) {
                this.state.kp = params.kp;
                this.state.ki = params.ki;
                this.state.kd = params.kd;
                this.state.mu = params.mu;
                this.state.r_earth = params.r_earth;
                this.state.rho_0 = params.rho_0;
                this.state.h_scale = params.h_scale;
                this.state.solar_pressure = params.solar_pressure;
                this.state.c_light = params.c_light;
                this.state.max_torque = params.max_torque;
                this.state.timeScale = params.timeScale || simulationConfig.defaultTimeScale;
                const qNorm = Math.sqrt(params.q_desired.w ** 2 + params.q_desired.x ** 2 + params.q_desired.y ** 2 + params.q_desired.z ** 2);
                if (qNorm === 0) {
                    console.warn('Invalid quaternion (zero norm), using default [1, 0, 0, 0]');
                    this.state.q_desired = new Ammo.btQuaternion(1, 0, 0, 0);
                } else {
                    this.state.q_desired = new Ammo.btQuaternion(
                        params.q_desired.w / qNorm,
                        params.q_desired.x / qNorm,
                        params.q_desired.y / qNorm,
                        params.q_desired.z / qNorm
                    );
                }
            },

            update: function(objects) {
                if (!objects[0]) return;
                const { body, mesh } = objects[0];
                const transform = new Ammo.btTransform();
                body.getMotionState().getWorldTransform(transform);
                const r = transform.getOrigin();
                const v = body.getLinearVelocity();
                const epsilon = 1e-6;
                const rNorm = Math.max(epsilon, Math.sqrt(r.x() * r.x() + r.y() * r.y() + r.z() * r.z()));

                if (rNorm <= this.state.r_earth || isNaN(rNorm)) {
                    console.warn('Invalid rNorm, stopping simulation:', rNorm);
                    body.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
                    Ammo.destroy(transform);
                    return;
                }

                // Gravitational acceleration
                const mu = isNaN(this.state.mu) || this.state.mu <= 0 ? 3.986e14 : this.state.mu;
                const aGravity = new Ammo.btVector3(
                    -mu * r.x() / Math.pow(rNorm, 3),
                    -mu * r.y() / Math.pow(rNorm, 3),
                    -mu * r.z() / Math.pow(rNorm, 3)
                );

                // Atmospheric drag
                const alt = rNorm - this.state.r_earth;
                const rho = this.state.rho_0 * Math.exp(-alt / this.state.h_scale);
                const vNorm = Math.sqrt(v.x() * v.x() + v.y() * v.y() + v.z() * v.z());
                const dragAcc = new Ammo.btVector3(
                    isNaN(rho) || isNaN(vNorm) ? 0 : -0.5 * rho * 2.2 * 2.0 / this.state.mass * vNorm * v.x(),
                    isNaN(rho) || isNaN(vNorm) ? 0 : -0.5 * rho * 2.2 * 2.0 / this.state.mass * vNorm * v.y(),
                    isNaN(rho) || isNaN(vNorm) ? 0 : -0.5 * rho * 2.2 * 2.0 / this.state.mass * vNorm * v.z()
                );

                // Solar pressure
                const sunDir = new Ammo.btVector3(1.0, 0.0, 0.0);
                const solarAcc = (r.x() * sunDir.x() + r.y() * sunDir.y() + r.z() * sunDir.z()) < 0
                    ? new Ammo.btVector3(0, 0, 0)
                    : new Ammo.btVector3(
                        this.state.solar_pressure * 2.0 * 1.5 / this.state.mass * sunDir.x(),
                        this.state.solar_pressure * 2.0 * 1.5 / this.state.mass * sunDir.y(),
                        this.state.solar_pressure * 2.0 * 1.5 / this.state.mass * sunDir.z()
                    );

                // Total acceleration
                const aTotal = new Ammo.btVector3(
                    aGravity.x() + dragAcc.x() + solarAcc.x(),
                    aGravity.y() + dragAcc.y() + solarAcc.y(),
                    aGravity.z() + dragAcc.z() + solarAcc.z()
                );

                if (isNaN(aTotal.x()) || isNaN(aTotal.y()) || isNaN(aTotal.z())) {
                    console.warn('NaN in aTotal, skipping force application:', aTotal.x(), aTotal.y(), aTotal.z());
                    Ammo.destroy(transform);
                    Ammo.destroy(aGravity);
                    Ammo.destroy(dragAcc);
                    Ammo.destroy(solarAcc);
                    Ammo.destroy(aTotal);
                    return;
                }

                const force = new Ammo.btVector3(
                    aTotal.x() * this.state.mass,
                    aTotal.y() * this.state.mass,
                    aTotal.z() * this.state.mass
                );
                utils.applyForce(body, force);

                // Attitude control using quaternion error
                const q_current = body.getWorldTransform().getRotation(); // This is 'q' in your code
                const q_current_conjugate = new Ammo.btQuaternion(q_current.x(), -q_current.y(), -q_current.z(), q_current.w()); // (x,y,z,-w) or (-x,-y,-z,w) depending on convention, but in context of error it's just flipping axis sign. Here I'll use the convention from Three.js which is (x,y,z,-w) to match the expected inverse for rotation. Wait no, for the standard error calculation it should be ( -x, -y, -z, w ) or just w,x,y,z where it is treated as scalar first and then vector parts.

                // In quaternion algebra, q^-1 = q_conjugate / |q|^2. For unit quaternions, |q|^2 = 1.
                // So, q_current_inverse is effectively q_current_conjugate.
                // Ammo.js does not have a direct conjugate method, so you define it.
                // A common way for error quaternion: q_error = q_desired * q_current_conjugate

                // Let's assume you intended q_error = q_desired * q_current_conjugate
                // Ensure this.state.q_desired is normalized before this step.
                const qDesired = this.state.q_desired; // Already normalized if done correctly in init/updateParameters

                // Create an Ammo.btQuaternion for the conjugate of the current rotation
                const q_current_inv = new Ammo.btQuaternion(
                    -q_current.x(), // Conjugate: negate vector parts
                    -q_current.y(),
                    -q_current.z(),
                    q_current.w()
                );

                // Perform multiplication: qError = qDesired * q_current_inv
                // Ammo.js quaternions don't have a direct multiplication method in the way Three.js does
                // You would typically use `setA(q1) * setB(q2)` or manually apply the multiplication formula.

                // To simplify, let's use Three.js for quaternion math and then convert back to Ammo.js
                // This is often safer to ensure correct mathematical operations.
                const three_q_current = new THREE.Quaternion(q_current.x(), q_current.y(), q_current.z(), q_current.w());
                const three_q_desired = new THREE.Quaternion(this.state.q_desired.x(), this.state.q_desired.y(), this.state.q_desired.z(), this.state.q_desired.w());

                // Error quaternion: what rotation takes q_current to q_desired? (q_desired * q_current.inverse())
                const three_q_error = three_q_desired.multiply(three_q_current.invert()); // Or three_q_current.clone().invert().multiply(three_q_desired)
                const qError = new Ammo.btQuaternion();
                qError.setValue(three_q_error.x, three_q_error.y, three_q_error.z, three_q_error.w);

                // Normalize qError
                const qNorm = Math.sqrt(qError.w() * qError.w() + qError.x() * qError.x() + qError.y() * qError.y() + qError.z() * qError.z());
                if (qNorm < 1e-6 || isNaN(qNorm)) {
                    console.warn('Invalid qError norm, resetting:', qNorm);
                    qError.setValue(1, 0, 0, 0);
                } else {
                    qError.setValue(
                        qError.w() / qNorm,
                        qError.x() / qNorm,
                        qError.y() / qNorm,
                        qError.z() / qNorm
                    );
                }

                // Extract attitude error (vector part of quaternion error)
                const attErr = new Ammo.btVector3(qError.x(), qError.y(), qError.z());
                const attErrNorm = Math.sqrt(attErr.x() * attErr.x() + attErr.y() * attErr.y() + attErr.z() * attErr.z());
                const scalarPart = qError.w();

                // Shortest path correction (negate error if scalar part is negative)
                const sign = scalarPart >= 0 ? 1 : -1;
                const attErrScaled = new Ammo.btVector3(
                    attErr.x() * sign * 2, // Scale by 2 for error angle approximation
                    attErr.y() * sign * 2,
                    attErr.z() * sign * 2
                );

                // Integral term with anti-windup
                const maxIntegral = 10;
                const deltaTime = simulationConfig.defaultUpdateInterval * this.state.timeScale;
                this.state.integralError.setValue(
                    Math.max(-maxIntegral, Math.min(maxIntegral, this.state.integralError.x() + attErrScaled.x() * deltaTime)),
                    Math.max(-maxIntegral, Math.min(maxIntegral, this.state.integralError.y() + attErrScaled.y() * deltaTime)),
                    Math.max(-maxIntegral, Math.min(maxIntegral, this.state.integralError.z() + attErrScaled.z() * deltaTime))
                );

                if (isNaN(this.state.integralError.x()) || isNaN(this.state.integralError.y()) || isNaN(this.state.integralError.z())) {
                    console.warn('NaN in integralError, resetting');
                    this.state.integralError.setValue(0, 0, 0);
                }

                // PID control torque
                const angularVelocity = body.getAngularVelocity();
                const controlTorque = new Ammo.btVector3(
                    -this.state.kp * attErrScaled.x() - this.state.kd * angularVelocity.x() - this.state.ki * this.state.integralError.x(),
                    -this.state.kp * attErrScaled.y() - this.state.kd * angularVelocity.y() - this.state.ki * this.state.integralError.y(),
                    -this.state.kp * attErrScaled.z() - this.state.kd * angularVelocity.z() - this.state.ki * this.state.integralError.z()
                );

                // Gravity gradient torque
                const rHat = new Ammo.btVector3(r.x() / rNorm, r.y() / rNorm, r.z() / rNorm);
                const I_times_rHat = new Ammo.btVector3(
                    this.state.I.x() * rHat.x(),
                    this.state.I.y() * rHat.y(),
                    this.state.I.z() * rHat.z()
                );
                const ggTorque = new Ammo.btVector3(
                    rHat.y() * I_times_rHat.z() - rHat.z() * I_times_rHat.y(),
                    rHat.z() * I_times_rHat.x() - rHat.x() * I_times_rHat.z(),
                    rHat.x() * I_times_rHat.y() - rHat.y() * I_times_rHat.x()
                );
                const scaleFactor = Math.min(1e10, 3 * mu / Math.pow(rNorm, 3));
                ggTorque.setValue(
                    ggTorque.x() * scaleFactor,
                    ggTorque.y() * scaleFactor,
                    ggTorque.z() * scaleFactor
                );

                if (isNaN(ggTorque.x()) || isNaN(ggTorque.y()) || isNaN(ggTorque.z())) {
                    console.warn('NaN in ggTorque, skipping torque application:', ggTorque.x(), ggTorque.y(), ggTorque.z());
                    Ammo.destroy(transform);
                    Ammo.destroy(aGravity);
                    Ammo.destroy(dragAcc);
                    Ammo.destroy(solarAcc);
                    Ammo.destroy(aTotal);
                    Ammo.destroy(force);
                    Ammo.destroy(qError);
                    Ammo.destroy(qDesiredConjugate);
                    Ammo.destroy(attErr);
                    Ammo.destroy(attErrScaled);
                    Ammo.destroy(controlTorque);
                    Ammo.destroy(rHat);
                    Ammo.destroy(I_times_rHat);
                    Ammo.destroy(ggTorque);
                    return;
                }

                // Combine torques and enforce max torque limit
                const totalTorque = new Ammo.btVector3(
                    controlTorque.x() + ggTorque.x(),
                    controlTorque.y() + ggTorque.y(),
                    controlTorque.z() + ggTorque.z()
                );
                const torqueNorm = Math.sqrt(totalTorque.x() * totalTorque.x() + totalTorque.y() * totalTorque.y() + totalTorque.z() * totalTorque.z());
                if (torqueNorm > this.state.max_torque) {
                    const scale = this.state.max_torque / torqueNorm;
                    totalTorque.setValue(
                        totalTorque.x() * scale,
                        totalTorque.y() * scale,
                        totalTorque.z() * scale
                    );
                }

                if (isNaN(totalTorque.x()) || isNaN(totalTorque.y()) || isNaN(totalTorque.z())) {
                    console.warn('NaN in totalTorque, skipping torque application:', totalTorque.x(), totalTorque.y(), totalTorque.z());
                    Ammo.destroy(transform);
                    Ammo.destroy(aGravity);
                    Ammo.destroy(dragAcc);
                    Ammo.destroy(solarAcc);
                    Ammo.destroy(aTotal);
                    Ammo.destroy(force);
                    Ammo.destroy(qError);
                    Ammo.destroy(q_current_conjugate);
                    Ammo.destroy(q_current);
                    Ammo.destroy(q_current_inv);
                    Ammo.destroy(attErr);
                    Ammo.destroy(attErrScaled);
                    Ammo.destroy(controlTorque);
                    Ammo.destroy(rHat);
                    Ammo.destroy(I_times_rHat);
                    Ammo.destroy(ggTorque);
                    Ammo.destroy(totalTorque);
                    return;
                }

                utils.applyTorque(body, totalTorque);
                this.state.currentTime += simulationConfig.defaultUpdateInterval * this.state.timeScale;

                // Clean up
                Ammo.destroy(transform);
                Ammo.destroy(aGravity);
                Ammo.destroy(dragAcc);
                Ammo.destroy(solarAcc);
                Ammo.destroy(aTotal);
                Ammo.destroy(force);
                Ammo.destroy(qError);
                Ammo.destroy(q_current_conjugate);
                Ammo.destroy(attErr);
                Ammo.destroy(attErrScaled);
                Ammo.destroy(controlTorque);
                Ammo.destroy(rHat);
                Ammo.destroy(I_times_rHat);
                Ammo.destroy(ggTorque);
                Ammo.destroy(totalTorque);
            },
            getTelemetry: function(objects) {
                if (!objects[0]) return {};
                const { body } = objects[0];
                const transform = new Ammo.btTransform();
                body.getMotionState().getWorldTransform(transform);
                const r = transform.getOrigin();
                const v = body.getLinearVelocity();
                const rMag = Math.sqrt(r.x() * r.x() + r.y() * r.y() + r.z() * r.z());
                const theta = Math.acos(r.z() / rMag);
                const phi = Math.atan2(r.y(), r.x());
                const vR = v.x() * (r.x() / rMag) + v.y() * (r.y() / rMag) + v.z() * (r.z() / rMag);
                const vT = Math.sqrt(v.x() * v.x() + v.y() * v.y() + v.z() * v.z() - vR * vR);
                const q = transform.getRotation();
                const telemetry = {
                    'Time': { value: this.state.currentTime.toFixed(1), unit: 's' },
                    'Simulation Speed': { value: this.state.timeScale.toFixed(2), unit: 'x' },
                    'Radius': { value: rMag.toFixed(2), unit: 'm' },
                    'Latitude': { value: (90 - (theta * 180 / Math.PI)).toFixed(2), unit: 'deg' },
                    'Longitude': { value: (phi * 180 / Math.PI).toFixed(2), unit: 'deg' },
                    'Radial Velocity': { value: vR.toFixed(2), unit: 'm/s' },
                    'Tangential Velocity': { value: vT.toFixed(2), unit: 'm/s' },
                    'Azimuth': { value: (Math.atan2(r.y(), r.x()) * 180 / Math.PI).toFixed(2), unit: 'deg' },
                    'Quaternion': { value: [q.w(), q.x(), q.y(), q.z()], unit: '' },
                    'Position': { value: [r.x(), r.y(), r.z()], unit: 'm' }
                };
                Ammo.destroy(transform);
                return telemetry;
            }
            }),
            debrisField: new Simulation('debrisField', {
                name: 'Debris Field',
                cameraControl: 'orbit',
                parameters: [
                    { id: 'timeScale', label: 'Simulation Speed', type: 'scalar', control: 'slider', min: 0.1, max: 100, step: 0.1, defaultValue: 1.0 },
                    { id: 'debrisCount', label: 'Debris Count', type: 'scalar', defaultValue: 200 },
                    { 
                        id: 'fieldSize', 
                        label: 'Field Size', 
                        type: 'vector3d', 
                        ids: ['width', 'height', 'depth'],
                        control: 'slider', 
                        min: { width: 500, height: 500, depth: 500 }, 
                        max: { width: 5000, height: 5000, depth: 5000 }, 
                        step: { width: 100, height: 100, depth: 100 }, 
                        defaultValue: { width: 2000, height: 2000, depth: 2000 } 
                    }
                ],
                telemetry: [
                    { id: 'Time', type: 'scalar' },
                    { id: 'Simulation Speed', type: 'scalar' },
                    { id: 'Debris Count', type: 'scalar' },
                    { id: 'Collisions', type: 'scalar' }
                ],
                init: async function(params) {
                    world.setGravity(new Ammo.btVector3(0, 0, 0));
                    this.state = {
                        collisions: 0,
                        currentTime: 0.0,
                        timeScale: params.timeScale || simulationConfig.defaultTimeScale
                    };
                    const createdObjects = [];

                    camera.position.set(0, 0, params.fieldSize.depth * 1.5);
                    camera.lookAt(0, 0, 0);
                    camera.updateProjectionMatrix();

                    // Create debris objects
                    for (let i = 0; i < params.debrisCount; i++) {
                        const size = Math.random() * 20 + 5;
                        const sphereShape = new Ammo.btSphereShape(size);
                        const mass = size;
                        const inertia = new Ammo.btVector3(0, 0, 0);
                        sphereShape.calculateLocalInertia(mass, inertia);
                        const startTransform = new Ammo.btTransform();
                        startTransform.setIdentity();
                        startTransform.setOrigin(new Ammo.btVector3(
                            (Math.random() - 0.5) * params.fieldSize.width,
                            (Math.random() - 0.5) * params.fieldSize.height,
                            (Math.random() - 0.5) * params.fieldSize.depth
                        ));
                        const motionState = new Ammo.btDefaultMotionState(startTransform);
                        const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, sphereShape, inertia);
                        const body = new Ammo.btRigidBody(rbInfo);
                        body.setLinearVelocity(new Ammo.btVector3(
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200
                        ));
                        body.setCcdMotionThreshold(0.1); // Enable CCD for high-speed objects
                        body.setCcdSweptSphereRadius(size * 0.5);
                        world.addRigidBody(body);
                        const mesh = new THREE.Mesh(
                            new THREE.SphereGeometry(size),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xaaaaaa,
                                roughness: 0.5,
                                metalness: 0.3
                            })
                        );
                        scene.add(mesh);
                        createdObjects.push({ mesh, body });
                        Ammo.destroy(inertia);
                        Ammo.destroy(startTransform);
                        Ammo.destroy(rbInfo);
                    }

                    // Collision detection setup
                    world.setContactAddedCallback((cp, colObj0, colObj1) => {
                        this.state.collisions++;
                    });

                    createStarfield();
                    const axesHelper = new THREE.AxesHelper(params.fieldSize.width * 0.5);
                    scene.add(axesHelper);

                    return createdObjects;
                },
                updateParameters: function(params) {
                    this.state.timeScale = params.timeScale || simulationConfig.defaultTimeScale;
                },
                update: function(objects) {
                    this.state.currentTime += (simulationConfig.defaultUpdateInterval) * this.state.timeScale;
                },
                getTelemetry: function(objects) {
                    return {
                        'Time': { value: this.state.currentTime.toFixed(1), unit: 's' },
                        'Simulation Speed': { value: this.state.timeScale.toFixed(2), unit: 'x' },
                        'Debris Count': { value: objects.length, unit: '' },
                        'Collisions': { value: this.state.collisions, unit: '' }
                    };
                },
                cameraSettings: { 
                    position: new THREE.Vector3(0, 0, 3000),
                    near: 0.1,
                    far: 100000
                }
            })
        }

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(simulationConfig.defaultCamera.fov, simContainer.clientWidth / simContainer.clientHeight, simulationConfig.defaultCamera.near, simulationConfig.defaultCamera.far);
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(simContainer.clientWidth, simContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            // Initialize Ammo.js physics world
            const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            const broadphase = new Ammo.btDbvtBroadphase();
            const solver = new Ammo.btSequentialImpulseConstraintSolver();
            world = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
            world.getSolverInfo().set_m_numIterations(60);
            //world.getSolverInfo().set_m_solverMode(Ammo.SOLVER_USE_WARMSTARTING | Ammo.SOLVER_SIMD);

            chart = new Chart(document.getElementById('telemetry-chart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'No Data',
                        data: [],
                        borderColor: simulationConfig.chartColors[0],
                        backgroundColor: simulationConfig.chartColors[0] + '33',
                        tension: 0.2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            ticks: { color: '#88aaff' },
                            grid: { color: 'rgba(0, 190, 255, 0.2)' }
                        },
                        y: {
                            ticks: { color: '#88aaff' },
                            grid: { color: 'rgba(0, 190, 255, 0.2)' },
                            title: {
                                display: true,
                                text: 'Value',
                                color: '#88aaff'
                            }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#E0E0E0' } }
                    }
                }
            });

            const simList = document.getElementById('simulation-list-container');
            Object.entries(simulations).forEach(([id, sim]) => {
                const item = document.createElement('div');
                item.className = 'sim-item p-3 rounded-md cursor-pointer';
                item.textContent = sim.name;
                item.dataset.simId = id;
                item.dataset.tooltip = `Run ${sim.name} simulation`;
                simList.appendChild(item);
            });
            simList.addEventListener('click', (e) => {
                if (e.target.matches('.sim-item')) loadSimulation(e.target.dataset.simId);
            });

            eventListeners.push(
                    { element: document.getElementById('back-btn'), event: 'click', listener: unloadSimulation },
                    { element: document.getElementById('start-btn'), event: 'click', listener: startSimulation },
                    { element: document.getElementById('stop-btn'), event: 'click', listener: stopSimulation },
                    { 
                        element: document.getElementById('reset-btn'), 
                        event: 'click', 
                        listener: async () => {
                            try {
                                await resetSimulation(true);
                            } catch (error) {
                                console.error('Reset failed:', error);
                                document.getElementById('telemetry-panel').innerHTML += `
                                    <div class="bg-red-500/30 p-3 rounded-lg border border-red-500/20">
                                        <p class="text-sm text-red-400">Error</p>
                                        <p class="text-lg text-red-300">Reset failed: ${error.message}</p>
                                    </div>`;
                            }
                        }
                    },
                    { element: document.getElementById('open-params-btn'), event: 'click', listener: openParameterModal },
                    { element: document.getElementById('close-params-btn'), event: 'click', listener: () => parameterModal.classList.add('hidden') },
                    { element: document.getElementById('apply-live-btn'), event: 'click', listener: applyLiveParametersFromModal },
                    { element: document.getElementById('save-and-reset-btn'), event: 'click', listener: saveAndResetParametersFromModal },
                    { element: window, event: 'resize', listener: onWindowResize }
            );
            eventListeners.forEach(({ element, event, listener }) => element.addEventListener(event, listener));

            const audio = document.getElementById('background-audio');
            const audioBtn = document.getElementById('audio-btn');
            audioBtn.addEventListener('click', () => {
                audio.muted = !audio.muted;
                audioBtn.setAttribute('class','btn-primary ml-4')
                audioBtn.querySelectorAll('svg, i').forEach(el => el.remove());
                // Create new <i> with appropriate icon
                const icon = document.createElement('i');
                icon.setAttribute('data-lucide', audio.muted ? 'volume-x' : 'volume-2');
                icon.className = 'h-4 w-4';
                audioBtn.appendChild(icon);
                lucide.createIcons();
            });

            window.addEventListener('click', function playAudioOnce() {
                const audio = document.getElementById('background-audio');
                if (audio && (audio.paused || audio.muted)) {
                    audio.muted = false;
                    audio.play().catch(e => {});
                }
                window.removeEventListener('click', playAudioOnce);
            });

            // Sidebar toggle
            const sidebar = document.getElementById('sidebar');
            const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
            if (toggleSidebarBtn && sidebar) {
                toggleSidebarBtn.addEventListener('click', () => {
                    const isCollapsed = sidebar.classList.toggle('collapsed');
                    toggleSidebarBtn.setAttribute('class','btn-primary p-2')
                    toggleSidebarBtn.querySelectorAll('svg, i').forEach(el => el.remove());
                    // Create new <i> with appropriate icon
                    const iconEl = document.createElement('i');
                    iconEl.setAttribute('data-lucide', isCollapsed ? 'chevron-right' : 'chevron-left');
                    iconEl.className = 'h-4 w-4';
                    toggleSidebarBtn.append(iconEl)
                    lucide.createIcons();
                
                    toggleSidebarBtn.setAttribute('title', isCollapsed ? 'Expand Sidebar' : 'Collapse Sidebar');
                    
                    onWindowResize(); // Trigger resize
                });
            } else {
                console.error('Toggle button or sidebar not found');
            }

            createStarfield();
            lucide.createIcons();
            unloadSimulation();
            animate();
        }

        function createStarfield() {
            const v = [], c = [];
            for (let i = 0; i < 10000; i++) {
                v.push(THREE.MathUtils.randFloatSpread(50000), THREE.MathUtils.randFloatSpread(50000), THREE.MathUtils.randFloatSpread(50000));
                const brightness = Math.random() * 0.5 + 0.5;
                c.push(brightness, brightness, brightness);
            }
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.Float32BufferAttribute(v, 3));
            g.setAttribute('color', new THREE.Float32BufferAttribute(c, 3));
            starfield = new THREE.Points(g, new THREE.PointsMaterial({ size: 3, vertexColors: true, transparent: true }));
            scene.add(starfield);
        }


        function onWindowResize() {
            if (!renderer || !camera) return;
            const container = document.getElementById('simulation-container');
            
            setTimeout(() => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                // Update camera aspect ratio
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                
                // Update renderer size
                renderer.setSize(width, height, true); // true updates CSS size
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Force render to update viewport
                if (scene && camera) renderer.render(scene, camera);
                
                // Update chart if active
                if (chart && activeSimulation) {
                    const chartCanvas = document.getElementById('telemetry-chart');
                    chartCanvas.style.height = '200px';
                    chartCanvas.style.width = '100%';
                    chartCanvas.width = chartCanvas.parentElement.clientWidth;
                    try {
                        chart.resize();
                        chart.update('none');
                    } catch (error) {
                        console.error('Chart resize failed:', error);
                    }
                }
            }, 350); // Match sidebar transition duration
        }
                        


        function onSimulationStart() {
            // Assume this is called when a simulation starts
            activeSimulation = true; // Update based on your logic
            onWindowResize(); // Force resize on simulation start
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function setEngineStatus(isOnline) {
            const indicator = document.getElementById('engine-status-indicator');
            const text = document.getElementById('engine-status-text');
            indicator.className = `w-3 h-3 rounded-full ${isOnline ? 'bg-green-400 animate-pulse' : 'bg-yellow-400'} inline-block mr-2`;
            text.className = isOnline ? 'text-green-400' : 'text-yellow-400';
            text.textContent = isOnline ? 'ONLINE' : 'STANDBY';
        }

        async function loadSimulation(simId) {
            if (!simId || !simulations[simId]) {
                console.warn(`Invalid simulation ID: ${simId}`);
                return;
            }
            stopSimulation();
            activeSimulation = simulations[simId];
            document.getElementById('viewport-placeholder').innerHTML = '<div class="loading-spinner"></div><p>Loading simulation...</p>';
            const simList = document.getElementById('simulation-list-container');
            document.querySelectorAll('.sim-item').forEach(item => {
                item.classList.toggle('active', item.dataset.simId === simId);
                if (item.dataset.simId === simId) item.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            simList.classList.add('constrained');
            document.getElementById('viewport-placeholder').classList.add('hidden');
            document.getElementById('telemetry-placeholder').classList.add('hidden');
            document.getElementById('active-sim-controls').classList.remove('hidden');
            document.getElementById('active-sim-telemetry').classList.remove('hidden');
            document.getElementById('back-btn').classList.remove('hidden');
            document.getElementById('standby-panel').classList.add('hidden');
            setEngineStatus(true);
            try {
                await resetSimulation(true);
                document.getElementById('viewport-placeholder').innerHTML = '';
            } catch (error) {
                console.error('Failed to load simulation:', error);
                document.getElementById('viewport-placeholder').innerHTML = '<p>Error loading simulation. Please try again.</p>';
            }
        }



        function unloadSimulation() {
            stopSimulation();
            activeSimulation = null;
            document.querySelectorAll('.sim-item.active').forEach(i => i.classList.remove('active'));
            document.getElementById('simulation-list-container').classList.remove('constrained');
            document.getElementById('viewport-placeholder').classList.remove('hidden');
            document.getElementById('telemetry-placeholder').classList.remove('hidden');
            document.getElementById('active-sim-controls').classList.add('hidden');
            document.getElementById('active-sim-telemetry').classList.add('hidden');
            document.getElementById('back-btn').classList.add('hidden');
            document.getElementById('standby-panel').classList.remove('hidden');
            cleanupSimulation();
            setEngineStatus(false);
            onWindowResize();
        }

        function cleanupSimulation() {
            // Remove objects in objectsToUpdate
            objectsToUpdate.forEach(o => {
                if (o.mesh.isInstancedMesh) {
                    o.mesh.dispose();
                    scene.remove(o.mesh);
                } else {
                    scene.remove(o.mesh);
                    utils.disposeObject(o.mesh);
                }
                world.removeRigidBody(o.body);
                Ammo.destroy(o.body.getMotionState());
                Ammo.destroy(o.body);
            });
            objectsToUpdate = [];

            // Clear all scene children (meshes, lights, etc.)
            while (scene.children.length > 0) {
                const obj = scene.children[0];
                scene.remove(obj);
                utils.disposeObject(obj);
            }
            scene.background = null;
            renderer.clear();

            if (activeSimulation?.state) {
                if (activeSimulation.state.earthModel) {
                    utils.disposeObject(activeSimulation.state.earthModel);
                    activeSimulation.state.earthModel = null;
                }
                if (activeSimulation.state.satModel) {
                    utils.disposeObject(activeSimulation.state.satModel);
                    activeSimulation.state.satModel = null;
                }
                if (activeSimulation.userControls?.keys) {
                    activeSimulation.userControls.keys = {};
                }
            }

            inputManager.cleanup();
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);
        }

        /////////// Handle Mouse ////////
        function addCustomCameraListeners() {
            canvas.addEventListener('mousedown', cam_mousedown);
            canvas.addEventListener('mouseup', cam_mouseup);
            canvas.addEventListener('contextmenu', cam_contextmenu);
            canvas.addEventListener('mousemove', cam_mousemove_debounced);
            canvas.addEventListener('wheel', cam_wheel_debounced);
        }

        function removeCustomCameraListeners() {
            canvas.removeEventListener('mousedown', cam_mousedown);
            canvas.removeEventListener('mouseup', cam_mouseup);
            canvas.removeEventListener('contextmenu', cam_contextmenu);
            canvas.removeEventListener('mousemove', cam_mousemove_debounced);
            canvas.removeEventListener('wheel', cam_wheel_debounced);
        }
        // Handler functions
        function cam_mousedown(e) {
            if (e.button === 0) isMouseDown = true;
            if (e.button === 2) isRightMouseDown = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function cam_mouseup(e) {
            if (e.button === 0) isMouseDown = false;
            if (e.button === 2) isRightMouseDown = false;
        }

        function cam_contextmenu(e) { e.preventDefault(); }

        function cam_mousemove(e) {
            if (!isMouseDown && !isRightMouseDown) return;
            const dX = e.clientX - previousMousePosition.x, dY = e.clientY - previousMousePosition.y;
            if (isMouseDown) {
                const target = objectsToUpdate[0]?.cameraTarget || new THREE.Vector3(0, 0, 0);
                const spherical = new THREE.Spherical();
                const camPos = camera.position.clone().sub(target);
                spherical.setFromVector3(camPos);
                spherical.theta -= dX * 0.01;
                spherical.phi -= dY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                camPos.setFromSpherical(spherical);
                camera.position.copy(target).add(camPos);
            } else if (isRightMouseDown) {
                camera.position.x -= dX * 0.5;
                camera.position.y += dY * 0.5;
            }
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        // Use a stable debounce function!
        const cam_mousemove_debounced = utils.debounce(cam_mousemove, 10);

        function cam_wheel(e) {
            const target = objectsToUpdate[0]?.cameraTarget || new THREE.Vector3(0, 0, 0);
            const distance = camera.position.distanceTo(target);
            const delta = e.deltaY * 0.01 * distance;
            camera.position.addScaledVector(camera.position.clone().sub(target).normalize(), delta);
        }
        const cam_wheel_debounced = utils.debounce(cam_wheel, 10);

        ///////////////////
        function openParameterModal() {
            if (!activeSimulation) return;
            modalParameters = JSON.parse(JSON.stringify(currentParameters));
            renderParameterControls(modalParameters);
            parameterModal.classList.remove('hidden');
        }

        function validateModalInputs() {
            const form = document.getElementById('parameter-form');
            let isValid = true;
            form.querySelectorAll('.param-input').forEach(el => el.classList.remove('input-error'));
            document.getElementById('validation-error-msg').classList.add('hidden');

            activeSimulation.parameters.forEach(p => {
                if (p.type === 'vector3d' || p.type === 'vector4d') {
                    const ids = p.ids || (p.type === 'vector4d' ? ['w', 'x', 'y', 'z'] : ['x', 'y', 'z']);
                    ids.forEach(axis => {
                        const el = form.querySelector(`[data-param-id="${p.id}"][data-axis="${axis}"]`);
                        const val = utils.validateNumber(el.value, p.min?.[axis], p.max?.[axis]);
                        if (val === false) {
                            isValid = false;
                            el.classList.add('input-error');
                        } else {
                            modalParameters[p.id][axis] = val;
                            el.value = val;
                        }
                    });
                } else {
                    const el = form.querySelector(`[data-param-id="${p.id}"]`);
                    const val = utils.validateNumber(el.value, p.min, p.max);
                    if (val === false) {
                        isValid = false;
                        el.classList.add('input-error');
                    } else {
                        modalParameters[p.id] = val;
                        el.value = val;
                    }
                }
            });

            if (!isValid) document.getElementById('validation-error-msg').classList.remove('hidden');
            return isValid;
        }


        function applyLiveParametersFromModal() {
            if (!validateModalInputs()) return;
            currentParameters = JSON.parse(JSON.stringify(modalParameters));
            renderParameterControls(currentParameters);
            activeSimulation.updateParameters(currentParameters);
            updateTelemetryDisplay();
            parameterModal.classList.add('hidden');
        }

        async function saveAndResetParametersFromModal() {
            if (!validateModalInputs()) return;
            currentParameters = JSON.parse(JSON.stringify(modalParameters));
            parameterModal.classList.add('hidden');
            try {
                await resetSimulation(false);
            } catch (error) {
                console.error('Failed to reset simulation with new parameters:', error);
                document.getElementById('validation-error-msg').classList.remove('hidden');
                document.getElementById('validation-error-msg').textContent = 'Failed to apply parameters. Please try again.';
            }
        }

        function renderParameterControls(paramSource) {
            const quickPanel = document.getElementById('quick-access-parameters-panel');
            const modalForm = document.getElementById('parameter-form');
            quickPanel.innerHTML = '';
            modalForm.innerHTML = '';

            const quickAccessParams = activeSimulation.parameters.filter(p => p.control === 'slider');
            if (quickAccessParams.length > 0) {
                quickPanel.innerHTML = `<h2 class="text-base sm:text-lg font-semibold text-blue-300 mb-3 border-b border-blue-400/50 pb-2 flex items-center"><i data-lucide="sliders" class="h-4 w-4 mr-2"></i>Quick Parameters</h2>`;
            }

            activeSimulation.parameters.forEach(p => {
                const value = paramSource[p.id];
                const label = `${p.label}${p.units ? ` (${p.units})` : ''}`;
                let modalHtml = `<div><label class="block text-sm font-medium text-gray-300 mb-2" data-tooltip="${label}">${label}</label>`;
                if (p.type === 'vector3d' || p.type === 'vector4d') {
                    const ids = p.ids || (p.type === 'vector4d' ? ['w', 'x', 'y', 'z'] : ['x', 'y', 'z']);
                    modalHtml += `<div class="grid grid-cols-${ids.length} gap-2 vector-input">`;
                    ids.forEach((axis, index) => {
                        modalHtml += `<input data-param-id="${p.id}" data-axis="${axis}" type="number" value="${value[axis]}" min="${p.min?.[axis] ?? -Infinity}" max="${p.max?.[axis] ?? Infinity}" step="${p.step?.[axis] ?? 0.1}" class="param-input modal-input">`;
                    });
                    modalHtml += `</div></div>`;
                } else {
                    modalHtml += `<input data-param-id="${p.id}" type="number" value="${value}" min="${p.min ?? -Infinity}" max="${p.max ?? Infinity}" step="${p.step ?? 0.1}" class="param-input modal-input scalar-input"></div>`;
                }
                modalForm.innerHTML += modalHtml;

                if (p.control === 'slider') {
                    if (p.type === 'vector3d' || p.type === 'vector4d') {
                        const ids = p.ids || (p.type === 'vector4d' ? ['w', 'x', 'y', 'z'] : ['x', 'y', 'z']);
                        quickPanel.innerHTML += `<div><label class="block text-sm font-medium text-gray-300 mb-1" data-tooltip="${label}">${label}</label></div>`;
                        ids.forEach((axis, index) => {
                            quickPanel.innerHTML += `<div class="pl-4"><label class="block text-xs font-medium text-gray-400">${axis.toUpperCase()}</label><div class="flex items-center space-x-3 mt-1"><input data-param-id="${p.id}" data-axis="${axis}" type="range" min="${p.min?.[axis] ?? -Infinity}" max="${p.max?.[axis] ?? Infinity}" step="${p.step?.[axis] ?? 0.1}" value="${value[axis]}" class="param-input quick-input"><span id="${p.id}-${axis}-value" class="text-sm text-blue-300 w-20 text-right font-mono">${value[axis].toFixed(2)}</span></div></div>`;
                        });
                    } else {
                        quickPanel.innerHTML += `<div><label class="block text-sm font-medium text-gray-300 mb-1" data-tooltip="${label}">${label}</label><div class="flex items-center space-x-3 mt-1"><input data-param-id="${p.id}" type="range" min="${p.min}" max="${p.max}" step="${p.step}" value="${value}" class="param-input quick-input"><span id="${p.id}-value" class="text-sm text-blue-300 w-20 text-right font-mono">${value.toFixed(2)}</span></div></div>`;
                    }
                }
            });

            document.querySelectorAll('.quick-input').forEach(input => input.addEventListener('input', handleParameterChange));
            document.querySelectorAll('.modal-input').forEach(input => input.addEventListener('input', handleModalParameterChange));
            lucide.createIcons();
        }

        function handleModalParameterChange(e) {
            const { paramId, axis } = e.target.dataset;
            const paramDef = activeSimulation.parameters.find(p => p.id === paramId);
            let value = utils.validateNumber(e.target.value, paramDef.min?.[axis] ?? paramDef.min, paramDef.max?.[axis] ?? paramDef.max);
            if (value === false) return;
            if (paramDef.type === 'vector3d' || paramDef.type === 'vector4d') {
                modalParameters[paramId][axis] = value;
            } else {
                modalParameters[paramId] = value;
            }
            e.target.value = value;
        }

        function handleParameterChange(e) {
            const { paramId, axis } = e.target.dataset;
            const paramDef = activeSimulation.parameters.find(p => p.id === paramId);
            let value = utils.validateNumber(e.target.value, paramDef.min?.[axis] ?? paramDef.min, paramDef.max?.[axis] ?? paramDef.max);
            if (value === false) return;
            if (paramDef.type === 'vector3d' || paramDef.type === 'vector4d') {
                currentParameters[paramId][axis] = value;
                document.getElementById(`${paramId}-${axis}-value`).textContent = value.toFixed(2);
            } else {
                currentParameters[paramId] = value;
                document.getElementById(`${paramId}-value`).textContent = value.toFixed(2);
            }
            activeSimulation.updateParameters(currentParameters);
        }

        function startSimulation() {
            if (simulationRunning || !activeSimulation) return;
            simulationRunning = true;
            document.getElementById('start-btn').classList.add('btn-active');
            document.getElementById('stop-btn').classList.remove('btn-active');
            clock.start();
        }

        function stopSimulation() {
            simulationRunning = false;
            document.getElementById('stop-btn').classList.add('btn-active');
            document.getElementById('start-btn').classList.remove('btn-active');
            clock.stop();
        }

        async function resetSimulation(useDefaults) {
            if (!activeSimulation) return;
            stopSimulation();
            cleanupSimulation();
            if (useDefaults) {
                currentParameters = {};
                activeSimulation.parameters.forEach(p => {
                    if (p.type === 'vector3d' || p.type === 'vector4d') {
                        const ids = p.ids || (p.type === 'vector4d' ? ['w', 'x', 'y', 'z'] : ['x', 'y', 'z']);
                        currentParameters[p.id] = {};
                        ids.forEach((axis, index) => {
                            currentParameters[p.id][axis] = p.defaultValue[axis] !== undefined ? p.defaultValue[axis] : 0;
                        });
                    } else {
                        currentParameters[p.id] = p.defaultValue;
                    }
                });
            }
            try {
                objectsToUpdate = await activeSimulation.init(currentParameters); // Await async init
                if (!Array.isArray(objectsToUpdate)) {
                    console.error('init did not return an array:', objectsToUpdate);
                    objectsToUpdate = []; // Fallback to empty array
                }
            } catch (error) {
                console.error('Error initializing simulation:', error);
                objectsToUpdate = []; // Fallback to empty array on error
            }
            enableCameraControl(activeSimulation.cameraControl || 'none');
            camera.position.copy(activeSimulation.cameraSettings.position);
            camera.near = activeSimulation.cameraSettings.near || simulationConfig.defaultCamera.near;
            camera.far = activeSimulation.cameraSettings.far || simulationConfig.defaultCamera.far;
            camera.updateProjectionMatrix();
            camera.lookAt(objectsToUpdate[0]?.cameraTarget || new THREE.Vector3(0, 0, 0));
            renderParameterControls(currentParameters);
            updateTelemetryDisplay();
            resetChart();
            const userControlsPanel = document.getElementById('user-controls-panel');
            const userControlsContent = document.getElementById('user-controls-content');
            if (activeSimulation.userControls) {
                userControlsPanel.classList.remove('hidden');
                userControlsContent.innerHTML = activeSimulation.userControls.html;
                inputManager.setupButtonListeners(activeSimulation.id);
            } else {
                userControlsPanel.classList.add('hidden');
                userControlsContent.innerHTML = '';
            }
            lucide.createIcons();
            onWindowResize(); // Ensure renderer updates
        }

        function resetChart() {
            if (!activeSimulation) return;
            const telemetrySelect = document.getElementById('telemetry-select');
            telemetrySelect.innerHTML = '';
            const telemetryData = activeSimulation.getTelemetry(objectsToUpdate);
            
            const numericalTelemetry = [];
            
            activeSimulation.telemetry.forEach(t => {
                const { value } = telemetryData[t.id] || { value: null };
                if (typeof value === 'number' || 
                    (typeof value === 'string' && !isNaN(Number(value))) ||
                    (typeof value === 'string' && value.includes('/'))) {
                    numericalTelemetry.push(t.id); // Scalar values
                } else if (Array.isArray(value) && value.length > 0 && value.length <= 4 && 
                        value.every(v => typeof v === 'number' || (typeof v === 'string' && !isNaN(Number(v))))) {
                    const ids = t.ids || (t.type === 'vector4d' ? ['w', 'x', 'y', 'z'] : ['x', 'y', 'z']);
                    ids.slice(0, value.length).forEach((axis, index) => {
                        numericalTelemetry.push(`${t.id}.${axis}`);
                    });
                }
            });
            
            numericalTelemetry.forEach(t => {
                const option = document.createElement('option');
                option.value = t;
                option.textContent = t;
                telemetrySelect.appendChild(option);
            });

            chart.data.labels = [];
            chart.data.datasets = [{
                label: numericalTelemetry[0] || 'No Data',
                data: [],
                borderColor: simulationConfig.chartColors[0],
                backgroundColor: simulationConfig.chartColors[0] + '33',
                tension: 0.2,
                pointRadius: 0
            }];
            chart.options.scales.y.title.text = numericalTelemetry[0] || 'Value';
            try {
                chart.update('none');
                document.getElementById('telemetry-chart').style.display = 'block';
            } catch (error) {
                console.error('Chart initialization failed:', error);
            }

            telemetrySelect.addEventListener('change', () => {
                const selectedMetric = telemetrySelect.value;
                chart.data.datasets[0].label = selectedMetric;
                chart.data.datasets[0].data = [];
                chart.options.scales.y.title.text = selectedMetric;
                try {
                    chart.update('none');
                } catch (error) {
                    console.error('Chart update on metric change failed:', error);
                }
            });
        }

        function updateTelemetryDisplay() {
            if (!activeSimulation) {
                document.getElementById('telemetry-panel').innerHTML = '';
                return;
            }
            const telemetry = activeSimulation.getTelemetry(objectsToUpdate);
            let html = '';
            activeSimulation.telemetry.forEach(t => {
                const { value, unit } = telemetry[t.id] || { value: 'N/A', unit: '' };
                let displayValue;
                if (Array.isArray(value)) {
                    const ids = t.ids || (t.type === 'vector4d' ? ['w', 'x', 'y', 'z'] : ['x', 'y', 'z']);
                    displayValue = ids
                        .slice(0, value.length)
                        .map((axis, i) => `${axis}: ${Number(value[i]).toFixed(4)}`)
                        .join(', ');
                } else {
                    displayValue = typeof value === 'number' ? value.toFixed(2) : value;
                }
                html += `
                    <div class="bg-black/30 p-3 rounded-lg border border-blue-500/20">
                        <p class="text-sm text-gray-400">${t.id}</p>
                        <p class="telemetry-value ${Array.isArray(value) ? 'vector' : ''} text-lg">${displayValue} ${unit}</p>
                    </div>`;
            });
            document.getElementById('telemetry-panel').innerHTML = html;

            if (!simulationRunning) return;
            const telemetrySelect = document.getElementById('telemetry-select');
            const selectedMetric = telemetrySelect.value;
            chart.data.labels.push((clock.getElapsedTime()).toFixed(1));
            let value = telemetry[selectedMetric]?.value || 0;

            if (selectedMetric.includes('.')) {
                const [baseMetric, component] = selectedMetric.split('.');
                const telemetryDef = activeSimulation.telemetry.find(t => t.id === baseMetric);
                const vectorValue = telemetry[baseMetric]?.value;
                if (Array.isArray(vectorValue)) {
                    const ids = telemetryDef?.ids || (telemetryDef?.type === 'vector4d' ? ['w', 'x', 'y', 'z'] : ['x', 'y', 'z']);
                    const index = ids.indexOf(component);
                    value = vectorValue[index] !== undefined ? Number(vectorValue[index]) : 0;
                }
            } else if (typeof value === 'string' && value.includes('/')) {
                value = parseFloat(value.split('/')[0]) || 0;
            } else if (typeof value === 'string' && !isNaN(Number(value))) {
                value = parseFloat(value);
            } else if (typeof value !== 'number') {
                value = 0;
            }

            chart.data.datasets[0].data.push(value);
            if (chart.data.datasets[0].data.length > 300) {
                chart.data.labels.shift();
                chart.data.datasets[0].data.shift();
            }
            try {
                chart.update('none');
            } catch (error) {
                console.error('Chart update failed:', error);
            }
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (!activeSimulation || !Array.isArray(objectsToUpdate) || objectsToUpdate.length === 0) {
                starfield.rotation.y += 0.0001;
                if (renderer && camera) renderer.render(scene, camera);
                return;
            }
            let deltaTime = clock.getDelta();
            if (deltaTime > 0.1) deltaTime = simulationConfig.defaultUpdateInterval;
            const timeScale = activeSimulation.state.timeScale || simulationConfig.defaultTimeScale;
            if (simulationRunning) {
                world.stepSimulation(deltaTime * timeScale, 3, simulationConfig.defaultUpdateInterval * timeScale);
                activeSimulation.update(objectsToUpdate);
                inputManager.update(activeSimulation.id);
            }

            objectsToUpdate.forEach(o => {
                if (o.mesh.isInstancedMesh) {
                    const matrix = new THREE.Matrix4();
                    const transform = new Ammo.btTransform();
                    o.body.getMotionState().getWorldTransform(transform);
                    const pos = transform.getOrigin();
                    const quat = transform.getRotation();
                    matrix.setPosition(pos.x(), pos.y(), pos.z());
                    matrix.makeRotationFromQuaternion(new THREE.Quaternion(quat.x(), quat.y(), quat.z(), quat.w()));
                    matrix.scale(new THREE.Vector3(o.body.getCollisionShape().getRadius() || 1, o.body.getCollisionShape().getRadius() || 1, o.body.getCollisionShape().getRadius() || 1));
                    o.mesh.setMatrixAt(o.instanceId, matrix);
                    o.mesh.instanceMatrix.needsUpdate = true;
                    Ammo.destroy(transform);
                } else {
                    const transform = new Ammo.btTransform();
                    o.body.getMotionState().getWorldTransform(transform);
                    const pos = transform.getOrigin();
                    const quat = transform.getRotation();
                    o.mesh.position.set(pos.x(), pos.y(), pos.z());
                    o.mesh.quaternion.set(quat.x(), quat.y(), quat.z(), quat.w());
                    Ammo.destroy(transform);
                }
            });
            if (simulationRunning) {
                updateTelemetryDisplay();
            }
            if (orbitControls) orbitControls.update();
            camera.lookAt(objectsToUpdate[0]?.cameraTarget || new THREE.Vector3(0, 0, 0));
            starfield.rotation.y += 0.0001 * timeScale;
            if (renderer && camera) renderer.render(scene, camera);
        }
        init();
    });
</script>
</body>
</html>